/* automatically generated by rust-bindgen 0.71.1 */


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBLedMatrix {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LedCanvas {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LedFont {
    _unused: [u8; 0],
}
#[doc = " Parameters to create a new matrix.\n\n To get the defaults, non-set values have to be initialized to zero, so you\n should zero out this struct before setting anything."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBLedMatrixOptions {
    pub hardware_mapping: *const ::std::os::raw::c_char,
    pub rows: ::std::os::raw::c_int,
    pub cols: ::std::os::raw::c_int,
    pub chain_length: ::std::os::raw::c_int,
    pub parallel: ::std::os::raw::c_int,
    pub pwm_bits: ::std::os::raw::c_int,
    pub pwm_lsb_nanoseconds: ::std::os::raw::c_int,
    pub pwm_dither_bits: ::std::os::raw::c_int,
    pub brightness: ::std::os::raw::c_int,
    pub scan_mode: ::std::os::raw::c_int,
    pub row_address_type: ::std::os::raw::c_int,
    pub multiplexing: ::std::os::raw::c_int,
    #[doc = " The following boolean flags are off by default"]
    pub disable_hardware_pulsing: bool,
    pub show_refresh_rate: bool,
    pub inverse_colors: bool,
    pub led_rgb_sequence: *const ::std::os::raw::c_char,
    pub pixel_mapper_config: *const ::std::os::raw::c_char,
    pub panel_type: *const ::std::os::raw::c_char,
    pub limit_refresh_rate_hz: ::std::os::raw::c_int,
    pub disable_busy_waiting: bool,
}

#[doc = " Runtime options to simplify doing common things for many programs such as\n dropping privileges and becoming a daemon."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBLedRuntimeOptions {
    pub gpio_slowdown: ::std::os::raw::c_int,
    pub daemon: ::std::os::raw::c_int,
    pub drop_privileges: ::std::os::raw::c_int,
    pub do_gpio_init: bool,
    pub drop_priv_user: *const ::std::os::raw::c_char,
    pub drop_priv_group: *const ::std::os::raw::c_char,
}

#[doc = " 24-bit RGB color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

extern "C" {
    #[doc = " Universal way to create and initialize a matrix.\n The \"options\" struct (if not NULL) contains all default configuration values\n chosen by the programmer to create the matrix.\n\n If \"argc\" and \"argv\" are provided, this function also reads command line\n flags provided, that then can override any of the defaults given.\n The arguments that have been used from the command line are removed from\n the argv list (and argc is adjusted) - that way these don't mess with your\n own command line handling.\n\n The actual options used are filled back into the \"options\" struct if not\n NULL.\n\n Usage:\n ----------------\n int main(int argc, char **argv) {\n   struct RGBLedMatrixOptions options;\n   memset(&options, 0, sizeof(options));\n   options.rows = 32;            // You can set defaults if you want.\n   options.chain_length = 1;\n   struct RGBLedMatrix *matrix = led_matrix_create_from_options(&options,\n                                                                &argc, &argv);\n   if (matrix == NULL) {\n      led_matrix_print_flags(stderr);\n      return 1;\n   }\n   // do additional commandline handling; then use matrix...\n }\n ----------------"]
    pub fn led_matrix_create_from_options(
        options: *mut RGBLedMatrixOptions,
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
    ) -> *mut RGBLedMatrix;
}
extern "C" {
    pub fn led_matrix_create_from_options_const_argv(
        options: *mut RGBLedMatrixOptions,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut RGBLedMatrix;
}
extern "C" {
    #[doc = " The way to completely initialize your matrix without using command line\n flags to initialize some things.\n\n The actual options used are filled back into the \"options\" and \"rt_options\"\n struct if not NULL. If they are null, the default value is used.\n\n Usage:\n ----------------\n int main(int argc, char **argv) {\n   struct RGBLedMatrixOptions options;\n   struct RGBLedRuntimeOptions rt_options;\n   memset(&options, 0, sizeof(options));\n   memset(&rt_options, 0, sizeof(rt_options));\n   options.rows = 32;            // You can set defaults if you want.\n   options.chain_length = 1;\n   rt_options.gpio_slowdown = 4;\n   struct RGBLedMatrix *matrix = led_matrix_create_from_options_and_rt_options(&options, &rt_options);\n   if (matrix == NULL) {\n      return 1;\n   }\n   // do additional commandline handling; then use matrix...\n }\n ----------------"]
    pub fn led_matrix_create_from_options_and_rt_options(
        opts: *mut RGBLedMatrixOptions,
        rt_opts: *mut RGBLedRuntimeOptions,
    ) -> *mut RGBLedMatrix;
}

extern "C" {
    #[doc = " Simple form of led_matrix_create_from_options() with just the few\n main options. Returns NULL if that was not possible.\n The \"rows\" are the number of rows supported by the display, so 32, 16 or 8.\n\n Number of \"chained_display\"s tells many of these are daisy-chained together\n (output of one connected to input of next).\n\n The \"parallel_display\" number determines if there is one or two displays\n connected in parallel to the GPIO port - this only works with newer\n Raspberry Pi that have 40 interface pins.\n\n This creates a realtime thread and requires root access to access the GPIO\n pins.\n So if you run this in a daemon, this should be called after becoming a\n daemon (as fork/exec stops threads) and before dropping privileges."]
    pub fn led_matrix_create(
        rows: ::std::os::raw::c_int,
        chained: ::std::os::raw::c_int,
        parallel: ::std::os::raw::c_int,
    ) -> *mut RGBLedMatrix;
}
extern "C" {
    #[doc = " Stop matrix and free memory.\n Always call before the end of the program to properly reset the hardware"]
    pub fn led_matrix_delete(matrix: *mut RGBLedMatrix);
}
extern "C" {
    #[doc = " Get active canvas from LED matrix for you to draw on.\n Ownership of returned pointer stays with the matrix, don't free()."]
    pub fn led_matrix_get_canvas(matrix: *mut RGBLedMatrix) -> *mut LedCanvas;
}
extern "C" {
    #[doc = " Return size of canvas."]
    pub fn led_canvas_get_size(
        canvas: *const LedCanvas,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set pixel at (x, y) with color (r,g,b)."]
    pub fn led_canvas_set_pixel(
        canvas: *mut LedCanvas,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        r: u8,
        g: u8,
        b: u8,
    );
}
extern "C" {
    #[doc = " Copies pixels to rectangle at (x, y) with size (width, height)."]
    pub fn led_canvas_set_pixels(
        canvas: *mut LedCanvas,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        colors: *mut Color,
    );
}
extern "C" {
    #[doc = " Clear screen (black)."]
    pub fn led_canvas_clear(canvas: *mut LedCanvas);
}
extern "C" {
    #[doc = " Fill matrix with given color."]
    pub fn led_canvas_fill(canvas: *mut LedCanvas, r: u8, g: u8, b: u8);
}
extern "C" {
    #[doc = " Create a new canvas to be used with led_matrix_swap_on_vsync()\n Ownership of returned pointer stays with the matrix, don't free()."]
    pub fn led_matrix_create_offscreen_canvas(matrix: *mut RGBLedMatrix) -> *mut LedCanvas;
}
extern "C" {
    #[doc = " Swap the given canvas (created with create_offscreen_canvas) with the\n currently active canvas on vsync (blocks until vsync is reached).\n Returns the previously active canvas. So with that, you can create double\n buffering:\n\n   struct LedCanvas *offscreen = led_matrix_create_offscreen_canvas(...);\n   led_canvas_set_pixel(offscreen, ...);   // not shown until swap-on-vsync\n   offscreen = led_matrix_swap_on_vsync(matrix, offscreen);\n   // The returned buffer, assigned to offscreen, is now the inactive buffer\n   // fill, then swap again."]
    pub fn led_matrix_swap_on_vsync(
        matrix: *mut RGBLedMatrix,
        canvas: *mut LedCanvas,
    ) -> *mut LedCanvas;
}
extern "C" {
    pub fn led_matrix_get_brightness(matrix: *mut RGBLedMatrix) -> u8;
}
extern "C" {
    pub fn led_matrix_set_brightness(matrix: *mut RGBLedMatrix, brightness: u8);
}
extern "C" {
    pub fn set_image(
        c: *mut LedCanvas,
        canvas_offset_x: ::std::os::raw::c_int,
        canvas_offset_y: ::std::os::raw::c_int,
        image_buffer: *const u8,
        buffer_size_bytes: usize,
        image_width: ::std::os::raw::c_int,
        image_height: ::std::os::raw::c_int,
        is_bgr: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn load_font(bdf_font_file: *const ::std::os::raw::c_char) -> *mut LedFont;
}
extern "C" {
    pub fn baseline_font(font: *mut LedFont) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn height_font(font: *mut LedFont) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn create_outline_font(font: *mut LedFont) -> *mut LedFont;
}
extern "C" {
    pub fn delete_font(font: *mut LedFont);
}
extern "C" {
    pub fn draw_text(
        c: *mut LedCanvas,
        font: *mut LedFont,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        r: u8,
        g: u8,
        b: u8,
        utf8_text: *const ::std::os::raw::c_char,
        kerning_offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vertical_draw_text(
        c: *mut LedCanvas,
        font: *mut LedFont,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        r: u8,
        g: u8,
        b: u8,
        utf8_text: *const ::std::os::raw::c_char,
        kerning_offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn draw_circle(
        c: *mut LedCanvas,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        r: u8,
        g: u8,
        b: u8,
    );
}
extern "C" {
    pub fn draw_line(
        c: *mut LedCanvas,
        x0: ::std::os::raw::c_int,
        y0: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        r: u8,
        g: u8,
        b: u8,
    );
}

